# Multiclass Classification Framework - Handoff

**Date:** 2026-01-15
**Status:** Core implementation complete, ready for testing and analysis scripts

---

## üéØ What Was Built

Extended the binary classification framework to support **N-class One-vs-Rest (OvR) AUROC** with permutation-based null distributions and comprehensive confusion matrix tracking.

### Key Features
1. **Per-class OvR AUROC** - Each class vs all others combined
2. **Confusion matrices** - Per time bin, showing which classes get confused
3. **Temporal confusion profiles** - How classification breaks down over developmental time
4. **Embryo-level predictions** - Track individual embryo classification across time
5. **Defensive missing-class handling** - Robust to sparse data (e.g., WT absent at early timepoints)

---

## üìÅ Files Created/Modified

### Core Classification Module ‚úÖ
**`src/analyze/difference_detection/comparison_multiclass.py`**
- `compare_groups_multiclass()` - Main API function
- `_run_multiclass_classification()` - Time bin loop with OvR AUROC computation
- `_permutation_test_ovr()` - Permutation testing for each class
- `extract_temporal_confusion_profile()` - Extract confusion trends over time

**Key parameters:**
- `groups`: Dict mapping class labels to embryo ID lists
- `skip_bin_if_not_all_present`: Default `True` (conservative - skip bins with missing classes)
- `n_permutations`: Default 100 (increase to 500 for production)
- `bin_width`: Default 4.0 hours

### Plotting Functions ‚úÖ
**`results/mcolon/20260105_refined_embedding_and_metric_classification/utils/plotting_functions.py`**

Added:
- `plot_multiclass_ovr_aurocs()` - Overlay OvR AUROC curves for all classes
- `plot_confusion_matrix_heatmap()` - Seaborn heatmap with normalization
- `plot_temporal_confusion_profile()` - Single class confusion over time
- `plot_all_temporal_confusion_profiles()` - Grid of all classes

### Preprocessing Helpers ‚úÖ
**`results/mcolon/20260105_refined_embedding_and_metric_classification/utils/preprocessing.py`**

Added:
- `prepare_multiclass_auroc_data()` - Stack per-class results into long format
- `extract_temporal_confusion_profile()` - Extract confusion proportions
- `compute_per_embryo_accuracy()` - Identify ambiguous embryos

### Key Design Decisions

#### 1. Significance Threshold: p ‚â§ 0.01
- Single threshold (removed p < 0.05 tier)
- More conservative for biological claims
- Circle markers for significant points only
- Configurable via `significance_threshold` parameter in preprocessing

#### 2. Missing Class Handling
**Critical fix:** sklearn's `predict_proba()` only returns columns for **present** classes.

**Solution:**
```python
present_class_indices = np.array(sorted(np.unique(y)))
class_index_to_col = {cls_idx: col_idx for col_idx, cls_idx in enumerate(present_class_indices)}
```

This prevents **wrong probability indexing** when classes are absent at certain timepoints.

**User control:**
- `skip_bin_if_not_all_present=True` (default): Skip bins with missing classes
- `skip_bin_if_not_all_present=False`: Warn but proceed (fills missing probs with NaN)

---

## üìä Output Schema

### Return Structure
```python
results = compare_groups_multiclass(df, groups=groups, features='z_mu_b')

{
    'ovr_classification': {
        'CE': DataFrame,      # OvR AUROC for CE vs Rest
        'HTA': DataFrame,     # OvR AUROC for HTA vs Rest
        'NonPenHet': DataFrame,
        'WT': DataFrame,
    },
    'confusion_matrices': {
        20: DataFrame,        # Confusion matrix at 20 hpf
        24: DataFrame,        # Confusion matrix at 24 hpf
        ...
    },
    'embryo_predictions': DataFrame,  # Long format: embryo_id, time_bin, true_class, pred_class, pred_proba_*
    'summary': {
        'per_class': {...},           # Earliest sig, max AUROC per class
        'overall_accuracy': float,
    },
    'config': {...}
}
```

### Per-Class OvR DataFrame
Columns: `time_bin`, `time_bin_center`, `auroc_observed`, `auroc_null_mean`, `auroc_null_std`, `pval`, `n_positive`, `n_negative`, `positive_class`, `negative_class`

### Confusion Matrix DataFrame (per time bin)
```
           CE    HTA  NonPen    WT   (predicted)
CE         45      3       2     0
HTA         5     38       7     0
NonPen      2      8      85     5
WT          0      0       3    47
(true)
```

### Embryo Predictions DataFrame
Columns: `embryo_id`, `time_bin`, `true_class`, `pred_class`, `pred_proba_CE`, `pred_proba_HTA`, `pred_proba_NonPen`, `pred_proba_WT`, `is_correct`

---

## üöÄ Next Steps: Create Analysis Scripts

### Step 1: B9D2 Multiclass Analysis ‚è≥

**File to create:** `b9d2_multiclass_analysis.py`

**Template:**
```python
import sys
from pathlib import Path
PROJECT_ROOT = Path(__file__).resolve().parents[3]
sys.path.insert(0, str(PROJECT_ROOT))
sys.path.insert(0, str(PROJECT_ROOT / "src"))

import pandas as pd
from analyze.difference_detection.comparison_multiclass import compare_groups_multiclass

# Configuration
BIN_WIDTH = 2  # 2-hour bins
N_PERMUTATIONS = 500
OUTPUT_DIR = Path(__file__).parent / "output" / "b9d2_multiclass"
DATA_PATH = PROJECT_ROOT / "results/mcolon/20251219_b9d2_phenotype_extraction/data/b9d2_labeled_data.csv"

def load_and_prepare_data():
    df = pd.read_csv(DATA_PATH, low_memory=False)

    # CRITICAL: Map cluster categories
    df['cluster_categories'] = df['cluster_categories'].replace({
        'unlabeled': 'Not_Penetrant',
        'wildtype': 'Not_Penetrant'
    })

    return df

def define_groups(df):
    """Define 4-class groups: CE, HTA+BA_rescue, NonPenHets, WT"""

    # CE phenotype
    ce_ids = df[df['cluster_categories'] == 'CE']['embryo_id'].unique().tolist()

    # HTA + BA_rescue combined
    hta_ba_ids = df[
        df['cluster_categories'].isin(['HTA', 'BA_rescue'])
    ]['embryo_id'].unique().tolist()

    # Non-penetrant hets
    nonpen_het_ids = df[
        (df['genotype'] == 'b9d2_heterozygous') &
        (df['cluster_categories'] == 'Not_Penetrant')
    ]['embryo_id'].unique().tolist()

    # WT
    wt_ids = df[df['genotype'] == 'b9d2_wildtype']['embryo_id'].unique().tolist()

    groups = {
        'CE': ce_ids,
        'HTA_BA': hta_ba_ids,
        'NonPenHet': nonpen_het_ids,
        'WT': wt_ids,
    }

    return groups

def run_multiclass_classifications(df, groups):
    """Run multiclass classification with curvature, length, embedding."""

    feature_configs = {
        'curvature': ['baseline_deviation_normalized'],
        'length': ['total_length_um'],
        'embedding': 'z_mu_b'
    }

    all_results = {}

    for feature_name, features in feature_configs.items():
        print(f"\n{'='*60}")
        print(f"Feature: {feature_name}")
        print("="*60)

        results = compare_groups_multiclass(
            df,
            groups=groups,
            features=features,
            bin_width=BIN_WIDTH,
            n_permutations=N_PERMUTATIONS,
            n_jobs=-1,
            verbose=True
        )

        all_results[feature_name] = results

        # Save outputs
        output_subdir = OUTPUT_DIR / feature_name
        output_subdir.mkdir(parents=True, exist_ok=True)

        # Save per-class OvR AUROC CSVs
        for class_label, df_auroc in results['ovr_classification'].items():
            df_auroc.to_csv(output_subdir / f'ovr_auroc_{class_label}.csv', index=False)

        # Save confusion matrices
        cm_dir = output_subdir / 'confusion_matrices'
        cm_dir.mkdir(exist_ok=True)
        for time_bin, cm_df in results['confusion_matrices'].items():
            cm_df.to_csv(cm_dir / f'cm_t{time_bin}.csv')

        # Save embryo predictions
        if results['embryo_predictions'] is not None:
            results['embryo_predictions'].to_csv(
                output_subdir / 'embryo_predictions.csv', index=False
            )

        # Print summary
        print(f"\n{feature_name.upper()} Summary:")
        for class_label, class_summary in results['summary']['per_class'].items():
            print(f"  {class_label}:")
            print(f"    Earliest sig: {class_summary['earliest_significant_hpf']} hpf")
            print(f"    Max AUROC: {class_summary['max_auroc']:.3f} at {class_summary['max_auroc_hpf']} hpf")

    return all_results

if __name__ == '__main__':
    df = load_and_prepare_data()
    groups = define_groups(df)
    results = run_multiclass_classifications(df, groups)
```

### Step 2: B9D2 Multiclass Plotting ‚è≥

**File to create:** `b9d2_multiclass_plotting.py`

**What to plot:**
1. **Per-class OvR AUROC** - All 4 classes on one plot, per feature
2. **Confusion matrix heatmaps** - Key timepoints (e.g., 20, 30, 40, 50 hpf)
3. **Temporal confusion profiles** - Grid showing all 4 classes

**Template:**
```python
import pandas as pd
from pathlib import Path
from utils.plotting_functions import (
    plot_multiclass_ovr_aurocs,
    plot_confusion_matrix_heatmap,
    plot_all_temporal_confusion_profiles
)
from utils.preprocessing import extract_temporal_confusion_profile

OUTPUT_DIR = Path(__file__).parent / "output" / "b9d2_multiclass"
FIGURES_DIR = OUTPUT_DIR / "figures"
FIGURES_DIR.mkdir(parents=True, exist_ok=True)

# Color scheme
COLORS = {
    'CE': '#D32F2F',           # Red (strong phenotype)
    'HTA_BA': '#FF9800',       # Orange (late-onset)
    'NonPenHet': '#9E9E9E',    # Gray (control)
    'WT': '#4CAF50',           # Green (wildtype)
}

CLASS_LABELS = ['CE', 'HTA_BA', 'NonPenHet', 'WT']

def plot_ovr_aurocs_per_feature():
    """Plot OvR AUROC for each feature type."""
    for feature in ['curvature', 'length', 'embedding']:
        feature_dir = OUTPUT_DIR / feature

        # Load per-class OvR results
        ovr_results = {}
        for class_label in CLASS_LABELS:
            csv_path = feature_dir / f'ovr_auroc_{class_label}.csv'
            if csv_path.exists():
                ovr_results[class_label] = pd.read_csv(csv_path)

        # Plot
        plot_multiclass_ovr_aurocs(
            ovr_results=ovr_results,
            colors_dict=COLORS,
            title=f'B9D2 Multiclass: {feature.capitalize()}',
            save_path=str(FIGURES_DIR / f'ovr_auroc_{feature}.png')
        )

def plot_confusion_matrices_over_time():
    """Plot confusion matrix heatmaps at key timepoints."""
    feature_dir = OUTPUT_DIR / 'embedding'  # Use embedding as representative
    cm_dir = feature_dir / 'confusion_matrices'

    # Key timepoints
    timepoints = [20, 30, 40, 50]

    for t in timepoints:
        cm_path = cm_dir / f'cm_t{t}.csv'
        if not cm_path.exists():
            continue

        cm_df = pd.read_csv(cm_path, index_col=0)

        plot_confusion_matrix_heatmap(
            confusion_matrix_df=cm_df,
            title=f'Confusion Matrix: {t} hpf',
            normalize=True,
            save_path=str(FIGURES_DIR / f'confusion_matrix_t{t}.png')
        )

def plot_temporal_profiles():
    """Plot temporal confusion profiles for all classes."""
    # Load confusion matrices
    feature_dir = OUTPUT_DIR / 'embedding'
    cm_dir = feature_dir / 'confusion_matrices'

    confusion_matrices = {}
    for cm_path in cm_dir.glob('cm_t*.csv'):
        time_bin = int(cm_path.stem.split('_t')[1])
        confusion_matrices[time_bin] = pd.read_csv(cm_path, index_col=0)

    # Extract temporal profile
    temporal_profile = extract_temporal_confusion_profile(
        confusion_matrices=confusion_matrices,
        class_labels=CLASS_LABELS
    )

    # Plot grid
    plot_all_temporal_confusion_profiles(
        temporal_profile_df=temporal_profile,
        class_labels=CLASS_LABELS,
        colors_dict=COLORS,
        save_path=str(FIGURES_DIR / 'temporal_confusion_profiles.png')
    )

if __name__ == '__main__':
    plot_ovr_aurocs_per_feature()
    plot_confusion_matrices_over_time()
    plot_temporal_profiles()
```

### Step 3: CEP290 Multiclass Analysis ‚è≥

**Two configurations:**

1. **Biological grouping (3 classes):**
   - `HighToLow` vs `LowToHigh_Intermediate` vs `WT_Het`

2. **All classes (4 classes):**
   - `LowToHigh` vs `HighToLow` vs `Intermediate` vs `WT`

Follow similar pattern as B9D2 analysis.

---

## üîç Testing Checklist

Before running on real data, verify:

- [ ] **Import test**: Can import `compare_groups_multiclass` without errors
- [ ] **Small test**: Run on 2-class subset to verify matches binary `compare_groups()`
- [ ] **Missing class test**: Artificially remove a class at one timepoint, verify NaN handling
- [ ] **Confusion matrix**: Check that row sums = 1.0 when normalized
- [ ] **Temporal profile**: Verify proportions sum to 1.0 per class per timepoint
- [ ] **Plotting**: Generate all 3 plot types without errors

---

## üìù Known Considerations

### Data Requirements
- **Minimum 3 samples per class per time bin** (default `min_samples_per_class=3`)
- **At least 2 classes present** for classification to run
- Sparse data will result in fewer analyzable time bins

### Computational Cost
- **OvR approach**: N separate binary classifiers + N permutation tests per time bin
- With 4 classes, 500 permutations, 10 time bins: ~20,000 model fits
- Use `n_jobs=-1` to parallelize permutation testing
- Expect ~10-20 minutes per feature type on b9d2 data

### Biological Interpretation
- **OvR AUROC > 0.7**: Class is distinguishable from others
- **OvR AUROC ~ 0.5**: Class is not distinguishable (indistinguishable phenotype)
- **Confusion matrix**: Off-diagonal entries show phenotype similarity
- **Temporal profile**: Rising correct-classification proportion = phenotype emerges

---

## üêõ Troubleshooting

### "Skipped (missing classes: ['WT'])"
**Expected** - WT embryos may not be present at early developmental stages.
- Solution: This is normal. Use `skip_bin_if_not_all_present=False` only if you understand the reduced interpretability.

### "ValueError: y should be a 1d array"
**Cause:** Trying to pass multiclass labels directly to a binary function.
- Solution: Use `compare_groups_multiclass()`, not `compare_groups()`.

### Empty confusion matrices
**Cause:** All time bins were skipped due to missing classes or low samples.
- Solution: Check group sizes, reduce `min_samples_per_class`, or increase `bin_width`.

### NaN in pred_proba columns
**Expected** - Class was absent at that time bin.
- This is correct behavior! Downstream analysis should handle NaN appropriately.

---

## üìö References

### Key Functions
- `compare_groups_multiclass()` - Main API (src/analyze/difference_detection/comparison_multiclass.py:47)
- `plot_multiclass_ovr_aurocs()` - Visualization (utils/plotting_functions.py:449)
- `extract_temporal_confusion_profile()` - Confusion trends (utils/preprocessing.py:275)

### Example Usage
See templates above for B9D2 and CEP290 analyses.

---

## ‚úÖ Completion Status

| Task | Status | Location |
|------|--------|----------|
| Core multiclass classification | ‚úÖ Complete | `src/analyze/difference_detection/comparison_multiclass.py` |
| Plotting functions | ‚úÖ Complete | `utils/plotting_functions.py` |
| Preprocessing helpers | ‚úÖ Complete | `utils/preprocessing.py` |
| B9D2 analysis script | ‚è≥ Template ready | See Step 1 above |
| B9D2 plotting script | ‚è≥ Template ready | See Step 2 above |
| CEP290 analysis scripts | ‚è≥ Pending | Follow B9D2 pattern |
| Documentation | ‚úÖ Complete | This file |

---

## üéì Key Learnings

1. **sklearn's multiclass behavior**: `predict_proba()` only returns columns for classes present in training data
2. **Defensive programming**: Always map class indices to probability columns explicitly
3. **User control**: Provide `skip_bin_if_not_all_present` for transparency
4. **Reproducibility**: Track all decisions in `config` dict
5. **Sparse data**: Developmental time series naturally have missing classes at certain stages

---

**Next agent: Start with Step 1 (B9D2 analysis script) and run the full pipeline!** üöÄ
